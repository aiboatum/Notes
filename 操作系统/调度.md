<a id="markdown-1-调度" name="1-调度"></a>
# 1. 调度

多个进程或线程竞争 CPU 或其他资源时，就需要调度。操作系统中，**调度程序（scheduler）** 使用 **调度算法（scheduling algorithm）** 来完成这一工作。
<!-- TOC -->

- [1. 调度](#1-调度)
    - [1.1. 调度初识](#11-调度初识)
        - [1.1.1. 何时调度？](#111-何时调度)
            - [1.1.1.1. 时钟中断](#1111-时钟中断)
        - [1.1.2. 调度算法的分类](#112-调度算法的分类)
        - [1.1.3. 调度算法的目标（准则）](#113-调度算法的目标准则)
            - [1.1.3.1. 面向用户的准则](#1131-面向用户的准则)
                - [1.1.3.1.1. 周转时间](#11311-周转时间)
                - [1.1.3.1.2. 响应时间](#11312-响应时间)
                - [1.1.3.1.3. 截止时间](#11313-截止时间)
                - [1.1.3.1.4. 优先权准则](#11314-优先权准则)
            - [1.1.3.2. 面向系统的准则](#1132-面向系统的准则)
                - [1.1.3.2.1. 吞吐量](#11321-吞吐量)
                - [1.1.3.2.2. CPU 利用率](#11322-cpu-利用率)
                - [1.1.3.2.3. 均衡性](#11323-均衡性)
                - [1.1.3.2.4. 可预测性](#11324-可预测性)
    - [1.2. 调度算法](#12-调度算法)
        - [1.2.1. 作业的概念](#121-作业的概念)
        - [1.2.2. 先到先服务](#122-先到先服务)
        - [1.2.3. 最短作业优先](#123-最短作业优先)
        - [1.2.4. 最短剩余时间优先](#124-最短剩余时间优先)
        - [1.2.5. 轮转调度](#125-轮转调度)
        - [1.2.6. 优先级调度](#126-优先级调度)
            - [动态赋予优先级和静态赋予优先级](#动态赋予优先级和静态赋予优先级)
        - [多级队列](#多级队列)

<!-- /TOC -->

<a id="markdown-11-调度初识" name="11-调度初识"></a>
## 1.1. 调度初识

早期以磁带上的卡片作为输入的批处理系统时代，那时的调度算法很简单：依次运行磁带上的每一个作业。对于多道程序设计系统，调度算法要复杂一些，因为经常有多个用户等候服务。

为了需要调度？因为 CPU 资源有限，而 CPU 速度太快，操作系统可以通过分给各个进程一定时间来执行。这样就可以实现进程的并发。

<a id="markdown-111-何时调度" name="111-何时调度"></a>
### 1.1.1. 何时调度？

什么时候进行（需要）调度决策：
- 在创建一个新进程之后，需要决定是运行父进程还是运行子进程。由于这两个进程都处于就绪状态，所以优先运行哪个都是可以的。
- 一个进程退出时，必须做出调度决策。一个进程不再进行（因为它不再存在），所以必须从就绪进程集中选择另外某个进程。如果没有就绪的进程，通常会运行一个系统提供的空闲进程。
- 当一个进程阻塞在 I/O 和信号量或由于其他原因阻塞时，必须选择另一个进程运行。有时，阻塞的原因会成为选择的因素。例如，如果 A 是一个重要的进程，并正在等待 B 退出临界区，让 B 随后运行将会使得 B 退出临界区，从而可以让 A 运行。不过问题是，通常调度程序不拥有做出这种相关考虑的必要信息。
- 在一个 I/O 中断发生时，必须做出调度决策。如果中断来自 I/O 设备，而该设备现在完成了工作，某些被阻塞的等待该 I/O 的进程就成为可运行的就绪进程了。是否让新就绪的进程运行，这取决于调度程序的决定，或让中断发生时运行的进程继续运行，或让某个其他进程运行。

<a id="markdown-1111-时钟中断" name="1111-时钟中断"></a>
#### 1.1.1.1. 时钟中断

除了 I/O 中断，更应注意硬件时钟中断，时钟中断也需要做出调度决策。如 Linux 等分时操作系统，CPU 时间会分为多个时间片，程序执行完一个时间片之后，操作系统会重新选择一个任务来执行。而 CPU 并不知道什么时候时间片到了以及如何触发任务选择。这一切是通过 CPU 上一个外部时钟，功能简单视为一个倒数计数器，比如设置为 1000，然后每个时钟脉冲 -1，减到 0 的时候就给 CPU 发一个信号，这个信号就是时钟中断。CPU 之后会中断当前程序，来处理这个信号，这个信号的处理程序会重置计数器，并执行信号处理函数，如此反复，起到了时间分片的效果。

信号处理函数可以选择另一个任务执行，即进程切换。这些需要 CPU 在硬件层级进行支持。当然只要用到时间片的系统，或者说几乎常用的时钟，都使用到时钟中断。因为时钟中断可以维持系统时间，保证所有进程共享 CPU，即 CPU 的虚拟化。


根据如何处理时钟中断可以把调度算法分为两类：
1. **非抢占式**调度算法挑选一个进程，然后让该进程运行直至被阻塞（阻塞在 I/O 上或等待另一个进程），或者直到该进程自动释放 CPU。即使该进程运行了若干小时，它也不会被强迫挂起。这样做的结果是，在时钟中断发生时不会进行调度。在处理完时钟中断后，如果没有**优先级更高**的进程在等待，则被中断的进程会继续运行。
2. **抢占式**调度算法挑选一个进程，并且让该进程运行某个固定时段的最大值（如时间片用完了）。如果在该时段结束时，该进程仍在运行，它被挂起，而调度程序挑选另一个进程运行（如果存在一个就绪进程，否则调用系统产生的空进程）。进行抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便于把 CPU 控制返回给调度程序。**如果没有可用的时钟，那么非抢占式的调度就是惟一的选择**。简单理解，即进程就绪队列中如果有高优先级的进程，则会抢占（CPU 等资源）执行该进程。

reference: 
1. [时钟中断之后，进程调度程序是如何被执行的? - 知乎](https://www.zhihu.com/question/320636133)

<a id="markdown-112-调度算法的分类" name="112-调度算法的分类"></a>
### 1.1.2. 调度算法的分类

很显然，不同环境需要不同的调度算法。
- 批处理系统在商业领域仍有广泛应用。其工作特点使得，非抢占式或者每个进程都有长时间周期的抢占式算法，都是可以的。即应避免进程切换，而提升性能。

- 交互式系统，为了避免某个进程霸占 CPU 拒绝为其他进程服务，抢占是必须的。即便没有进程想永远运行，但是，某个进程由于一个程序错误，也可能无限期地排斥所有其他进程。为了避免这种现象，抢占是必须的。**服务器上的系统可以归于此类**，因为服务器通常为多个用户服务。

- 实时系统，对时间有所限制，抢占有时是不需要的，因为进程了解它们可能会长时间得不到运行，所以通常会很快地完成各自的工作而阻塞。

<a id="markdown-113-调度算法的目标准则" name="113-调度算法的目标准则"></a>
### 1.1.3. 调度算法的目标（准则）

1. 所有系统：
    - 公平：调度算法应当满足一定的公平性，即相似的（优先级相同的）进程应该得到相似的服务。如两个相似进程得到的 CPU 时间应当相似。
    - 策略强制执行：调度算法应强制按照系统策略执行，如安全控制的进程应当在一定条件下，强制挂起其他进程，运行安全控制进程。
    - 调度算法应使得系统的所有部分尽可能忙，即尽可能提升资源利用率。

2. 批处理系统：
    - 吞吐量：每小时最大作业数
    - 周转时间：从提交到终止间的最小时间
    - CPU 利用率

3. 交互式系统：
    - 响应时间：快速响应请求
    - 均衡性：满足用户的期望

4. 实时系统：
    - 满足截止时间：避免丢失数据
    - 可预测性：在多媒体系统中避免品质降低



<a id="markdown-1131-面向用户的准则" name="1131-面向用户的准则"></a>
#### 1.1.3.1. 面向用户的准则
<a id="markdown-11311-周转时间" name="11311-周转时间"></a>
##### 1.1.3.1.1. 周转时间

**周转时间（turnaround time）**：指从一个批处理作业**提交时刻**开始直到该作业**完成时刻**为止的统计时间。一般认为，多个作业的平均周转时间越小越好。假设 Ti 为作业 i 的周转时间，则平均周转时间 T 的计算公式为：

<img src="https://latex.codecogs.com/svg.latex?\Large&space;T=\frac{\sum_{i=1}^{n} Ti}{n}"/>

$$T=\frac{\sum_{i=1}^{n} Ti}{n}$$

其中周转时间，即提交时刻开始直到该作业完成时刻为止的统计时间，不一定都是系统为它服务的时间。也就是说，这其中可能包含等待的时间，如在就绪队列中排队所花费的时间。假设 Tsi 为系统为作业 i 提供服务的时间。则作业的周转时间 Ti 和 Tsi 之比，称为**带权周转时间**，则平均带权周转时间为：

$$W=\frac{\sum_{i}^{n}\frac{Ti}{Tsi}}{n}$$

<a id="markdown-11312-响应时间" name="11312-响应时间"></a>
##### 1.1.3.1.2. 响应时间

**响应时间**：从发出指令到得到响应之间的时间。一般用于交互式系统。例如，在有后天进程运行（如，从网络上读取和存储电子邮件，后台播放音频等等）的个人 PC 上，用户请求启动一个程序或打开一个文件应该优先于后台的工作。一般认为，能够让所有交互式请求首先运行的则是好服务（好的调度原则）。

<a id="markdown-11313-截止时间" name="11313-截止时间"></a>
##### 1.1.3.1.3. 截止时间

**截止时间**：指任务必须开始执行的最迟时间，或必须完成的最迟时间。对于严格的实时系统，其调度必须保证这一点。例如，如果计算机正在控制一个以正常速率产生数据的设备，若一个按时运行的数据收集进程出现失败，会导致数据丢失。所以，实时系统应该保证满足所有（或大多数的）截止时间要求。

<a id="markdown-11314-优先权准则" name="11314-优先权准则"></a>
##### 1.1.3.1.4. 优先权准则

即重要的进程、作业、任务等优先处理。

<a id="markdown-1132-面向系统的准则" name="1132-面向系统的准则"></a>
#### 1.1.3.2. 面向系统的准则
<a id="markdown-11321-吞吐量" name="11321-吞吐量"></a>
##### 1.1.3.2.1. 吞吐量

**吞吐量**：系统每小时完成的**作业的数量**。能使吞吐量最大化的调度算法不一定是最小周转时间。如对于确定的短作业和长作业的一个组合，总是运行短作业而不运行长作业的调度程序，可能会获得出色的吞吐性能（每小时大量的短作业），但是其代价是对于长的作业周转时间很差。如果短作业以一个稳定的速率不断到达，长作业可能根本运行不了，这样的平均周转时间是无限长，但得到了高吞吐量。

<a id="markdown-11322-cpu-利用率" name="11322-cpu-利用率"></a>
##### 1.1.3.2.2. CPU 利用率

**CPU 利用率**：用于的对批处理系统的度量。一般来说，吞吐量和周转时间是更好的准则。CPU 利用率并不那么重要。

<a id="markdown-11323-均衡性" name="11323-均衡性"></a>
##### 1.1.3.2.3. 均衡性

**均衡性**：应当有效利用其他各类资源，如 CPU，存储设备，I/O 设备等。

用户对做一件事情需要多长时间总是有一个固有的（不过通常不正确）看法。当认为一个请求很复杂，从而需要较多的时间时，用户会接受这个时间。但是当认为一个请求很简单，但也需要较多的时间时，用户就会急躁。例如，如果点击一个图标花费了 60s 发送完成一份传真，用户大概会接受，因为用户不期望 5s 可以得到传真。

然而，当传真发送完成，用户点击断开电话连接的图标时，该用户期待很快完成这个操作。如果 30s 还不能完成这个断开操作，用户可能就会抱怨。而 60s 可能就无法忍受了。

<a id="markdown-11324-可预测性" name="11324-可预测性"></a>
##### 1.1.3.2.4. 可预测性

**可预测性**对于实时系统来说是很重要的。有些不能满足截止时间要求并不严重，但是如果音频进程运行的错误太多，那么音质就会下降的很快。为了避免这个问题，进程调度程序必须是高度可预测和有规则的。

<a id="markdown-12-调度算法" name="12-调度算法"></a>
## 1.2. 调度算法

下面几个调度算法一般用在批处理系统中，但是现代操作系统已经包含了各类系统的特点。因此，这里不区分系统来介绍调度算法。

<a id="markdown-121-作业的概念" name="121-作业的概念"></a>
### 1.2.1. 作业的概念

作业是应用层面的概念，和任务（task）类似，指为达到一定业务目的，如统计数据并打印，而实施的一系列技术性操作，如链接数据库，执行 SQL，导出数据，统计整理，格式化，输出到打印机。

作业的进行依赖至少一个进程。

因此，作业一般被定义为。**作业是用户在一次算题过程中或一个事务处理中要求计算机系统所做的工作的集合**。作业比程序更为广泛，不仅包含通常的程序和数据，还包含作业说明书。系统通过作业说明书控制文件形式的程序和数据，使之执行和操作。

reference: 
1. [作业和进程的区别？ - js xs的回答 - 知乎](https://www.zhihu.com/question/343542767/answer/808122521)



<a id="markdown-122-先到先服务" name="122-先到先服务"></a>
### 1.2.2. 先到先服务

**先到先服务（first-come first-served）**算法是最简单的调度算法。进程调度程序按照它们请求 CPU 的顺序使用 CPU。基本上，有一个就绪进程的单一队列。当正在运行的进程被阻塞时，队列中的第一个进程就接着运行。在被阻塞的进程变为就绪时，就像一个新来到的进程一样，排到队列的末尾。FCFS 算法是一种非抢占式的算法，即一个进程会运行到它所期望的时间，不会中断该进程。

> 一般用于批处理系统。进行作业调度。

FCFS 服务的优点：易于理解，实现非常简单，利于 CPU 密集型进程，不利于 I/O 密集型的进程

FCFS 服务的缺点：性能太差。比如有一个一次运行 1 秒钟的计算密集型进程和很少使用 CPU 但是每个都要进行 1000 次磁盘读操作才能完成的大量 I/O 密集型进程存在。计算密集型进程运行 1 秒。接着所有的 I/O 进程开始运行并读磁盘。当该计算密集型进程获得其磁盘块时，它运行下一个 1 秒，紧接着的是所有 I/O 进程。

这样做的结果是，每个 I/O 进程在每秒钟内读到一个磁盘块，要花费 1000 秒才能完成操作。如果有一个调度算法每隔 10ms（1s=1000ms） 抢占计算密集型进程（即挂起计算密集型进程，执行 I/O 密集型进程），那么 I/O 进程将在 10 秒内完成而不是 1000 秒，而且不会对计算密集型进程产生对少延迟。

<a id="markdown-123-最短作业优先" name="123-最短作业优先"></a>
### 1.2.3. 最短作业优先

当输入队列中有若干个同等重要的作业被启动时，调度程序应使用**最短作业优先（shortest job first）**算法。最短作业优先和下一节的最短剩余时间优先要求，有关进程（作业）的运行时间必须提前掌握。

考虑下面的例子。如有 4 个作业 ABCD，运行时间分别为 8、4、4、4 分钟。若按照 `A->B->C->D` 的方式运行，则 A 的周转时间为 8min，B 为 12min，C 为 16min，D 为20min，平均为 14min。

现在按照最短作业优先算法运行，即 `B->C->D->A` 运行。周转时间分别为 4、8、12、20min，平均为 11min。可以证明最短作业优先是最优的。

> 应当注意的是，只有当所有的作业都可运行的情形下，即都在就绪队列中时，最短作业优先才是最优的。例如下面的例子。

有 5 个作业，ABCDE，运行时间分别为 2、4、1、1、1。但是它们到达（就绪队列）的时间为 0、0、3、3、3。最开始，就绪队列只有 A 和 B，因为其他三个作业还没到达。使用最短作业优先，运行顺序为 `A->B->C->D->E`。此时计算的平均等待（周转）时间为 4.6。但是，以 `B->C->D->E->A` 的顺序运行作业，平均等待时间为 4.4。

<a id="markdown-124-最短剩余时间优先" name="124-最短剩余时间优先"></a>
### 1.2.4. 最短剩余时间优先

最短作业优先是非抢占式的，其抢占式的版本为**最短剩余时间优先（shortest remaining time next）**算法。该算法总是选择剩余运行时间最短的进程运行（有关的运行时间必须提前知晓）。当一个新的进程到达时，其整个时间同当前进程的剩余时间作比较。如果新的进程比当前运行进程需要更少的时间，当前进程就被挂起，而运行新的进程。这种方式可以使新的短作业获得良好的服务。

<a id="markdown-125-轮转调度" name="125-轮转调度"></a>
### 1.2.5. 轮转调度

**轮转调度**是最古老、最简单、最公平且使用最广的调度算法。每个进程分配一个时间片。如果在时间结束时，该进程还在运行，则将剥夺 CPU 并分配给另一个进程。如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。时间片轮转调度程序，维护一张可运行的进程列表，当一个进程用完它的时间片，移到队列末尾。

时间片轮转调度中，最重要的是其时间片长度。加入进程切换需要 1ms，时间片为 4ms，那么 CPU 将有 20% （即 CPU 花费 4ms 做完有用的工作，再花费 1ms 进行线程切换， 1/5=0.2）的时间浪费在管理开销上（进程切换管理）。

为了提高 CPU 的效率，我们可以将时间片设置为 100ms，这样浪费的时间只有 1%。但是，如果 在一段非常短的时间间隔内到达 50 个请求，并且对 CPU 有不同的需求。这 50 个进程放在排队就绪队列中，如果 CPU 空闲，第一个进程会立即执行，第二个直到 100ms 以后才会启动，以此类推。假设所有的 其他进程都用足了它们的时间片的话，最不幸的是最后一个进程在获得运行机会之前将不得不等待 5s。如果一些在队列后端附近的请求仅要求几毫秒的 CPU 时间，情况会更加糟糕。此时，短的时间片将会提供更好的服务。

> 时间片太短会导致过多的进程切换，降低 CPU 效率；而设置的太长会引起对短的交互请求的响应时间变长。因此将时间片设为 20ms\~ 50ms 是一个合理的折中选择。


<a id="markdown-126-优先级调度" name="126-优先级调度"></a>
### 1.2.6. 优先级调度

轮转调度的隐含前提是，所有的进程同等重要。显然许多情况下，这是不现实的。因此采用**优先级调度**，给每个进程赋予一个优先级，优先级最高的**可运行进程**会先执行。

为了防止高优先级的进程无休止地运行下去，调度程序可以在每个时钟滴答（即每个时钟中断）降低当前进程的优先级。如果这个动作导致该进程的优先级低于就绪队列的进程的**次高优先级**的进程，则进行进程切换。一个可采用的方法，每个进程被赋予一个可运行的最大时间片，当这个时间片用完时，下一个次高优先级的进程获得机会运行。

<a id="markdown-动态赋予优先级和静态赋予优先级" name="动态赋予优先级和静态赋予优先级"></a>
#### 动态赋予优先级和静态赋予优先级

优先级可以**静态赋予**或**动态赋予**。

静态赋予即，提前确定好各类进程的优先级。整个进程运行期间保持不变。

优先级可以由系统动态确定。例如，有些进程为 I/O 密集型，其多数时间用来等待 I/O 结束。当这样的进程需要 CPU 时，应立即分配给它 CPU，以便启动下一个 I/O 请求，这样就可以在另一个进程计算的同时，执行 I/O 操作（I/O 操作和 CPU 占用不冲突）。这类 I/O 密集型进程长时间等待 CPU 只会造成无谓地等待和长时间占用内存。一般来说，使得 I/O 密集型进程获得较好服务的一种简单算法是，将其优先级设为 1/f，f 为该进程在上一时间片所占的部分。例如，一个在其 50ms 时间片中只使用 1ms 的进程将获得优先级 50，而在阻塞之前用掉 25ms 的进程将获得优先级 2，而使用掉全部时间片的进程将获得优先级 1。

一般来说，大多采用动态赋予优先权的调度，以上例子中的算法可以可描述为：
~~~
优先级 = 1/f = (等待时间+要求服务时间)/要求服务时间
      = 响应时间/要求服务时间
      = 相应比
~~~

更一般的，一组进程按照优先级分类。各类之间采用优先级调度，而在各类进程之间内部（即具有相同优先级）将采用轮转调度。
```
队列       
优先级 4-->[进程 A]-->[进程 B]-->[进程 C]
优先级 3-->[]-->[]-->[]-->[]-->[]
优先级 2-->[]
优先级 1
```
以上的例子中，其调度算法如下：只要存在优先级为 4 的可运行进程，就按照轮转法为每个（优先级 4的）进程运行一个时间片，此时不理会优先级低的进程。若优先级 4 的进程为空，则按照轮转法运行优先级 3 的进程。依次类推。这里就可以看出，**如果不偶尔对优先级进行调整，则低优先级的进程很可能会用于运行不了（即产生饥饿现象）。


<a id="markdown-多级队列" name="多级队列"></a>
### 多级队列

