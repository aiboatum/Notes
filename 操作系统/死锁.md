# 死锁

死锁（deadlock），指多个进程因竞争资源（尤其指不可抢占式资源）而陷入了一个死循环【相互等待】。

因为进程**排他性**地访问**若干**资源而不是一种。如进程 A 请求使用扫描仪，并被授权使用。但进程 B 首先请求了 CD 刻录机，也被授权使用。现在， A 请求使用 CD 刻录机，但该请求在 B 释放资源前会被拒绝。但是，B 非但不放弃 CD 刻录机，而去请求扫描仪。这时，两个进程就陷入了死循环。

> 死锁现象，不止发生在进程之间。也可能发生在机器之间。

## 死锁产生的原因

1. 系统资源的竞争（不可抢占资源）
    - 对可抢占资源的竞争不会引起死锁
2. 进程运行顺序不当
    - 进程在运行过程中，请求和释放资源的顺序不当，可能会导致死锁
        - 例如并发进程 A,B 分别保持资源 R1,R2，而进程 A 申请资源 R2、进程 B 申请资源 R1 时
    - 信号量的使用不当也会造成死锁，如下

```c++
// case 1： 这种情况不会造成死锁
using semaphore = int; 
semaphore resource_1, resource_2; 
void process_A(void){

    down(&resource_1);
    down(&resource_2);
    use_both_resources();
    up(&resource_1);
    up(&resource_2);

}
void process_B(void){

    down(&resource_1);
    down(&resource_2);
    use_both_resources();
    up(&resource_1);
    up(&resource_2);

}

// case 2： 这种情况可能会造成死锁
void process_A(void){

    down(&resource_1);
    down(&resource_2);
    use_both_resources();
    up(&resource_2);
    up(&resource_1);

}
void process_B(void){

    down(&resource_2);
    down(&resource_1);
    use_both_resources();
    up(&resource_1);
    up(&resource_2);

}
```

## 死锁产生的必要条件

1971 年，Coffman 等人提出，死锁必须同时满足以下四个条件。

1. 互斥条件：独占性，一段时间资源仅可一个进程占有
2. 不剥夺条件（不可抢占条件）：进程获得的资源，未使用完之前，不可被剥夺【即只能自己主动释放】
3. 请求并保持条件（占有和等待条件）：进程已经保持了一个资源，但又提出新的资源请求，而该资源被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放
4. 循环（环路）等待条件：存在循环等待链

## 死锁的处理策略

1. 忽略该问题
2. 检测死锁并恢复
3. 仔细对资源进行分配，动态地避免死锁
4. 通过破坏引起死锁的『四个必要条件之一』，即可防止死锁发生

### 忽略死锁

**鸵鸟算法**，假装死锁没有发生，即忽略潜在可能发生的问题。

前提是，问题出现的概率很低。

### 死锁检测 和 死锁恢复

最简单就是利用检测『有向图环路』的方法【如，快慢指针】，可以检测。

至于死锁恢复，有如下几种方法：

1. 利用抢占恢复

将某一个资源从持有者抢占走，给另一个进程使用，用完再返回所有权。

这种方法是否可行主要取决于资源本身的特性。该方法恢复比较困难。

2. 利用回滚恢复

进程每次申请资源，都会记录在一个称为**检查点**上，该检查点包括存储映像，资源状态，即哪些资源分配给了该进程。

这样，当进程执行的时候，将会有一系列的检查点文件。一旦检测到死锁，就很容易发现需要哪些资源。为了恢复，要从较早的检查点开始，这样拥有所需要资源的进程会进行**rollback**，回滚到一个时间点。

3. 通过杀死其他进程恢复

这是最直接和简单的方法，直接 **kill** 掉『环』上的一个进程或若干个进程。如果走运的话，其他进程将会继续运行。否则，将继续杀死其他进程直到打破死锁环。

这时候，选择杀死哪些进程就显得尤为重要了。当然是选择哪些可以从头开始而且不会带来副作用的进程。

## 死锁避免

## 死锁 和 饥饿

饥饿是指一个进程一直得不到资源。

死锁和饥饿都是由于进程竞争资源引起的。

但是死锁进程的一定占有资源（占有等待条件），饥饿一般不占有资源。
