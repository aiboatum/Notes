
> 当采用分段存储管理时，可以满足用户的和程序员，实现信息保护和段的共享。

1. 怎么保护的？
2. 怎么共享的？

## 共享段表

为了实现段的共享，可在系统中设置一个『共享段表』，所有共享段都在共享段表中占有一表项。表项中记录了共享段的
- 段号
- 段长
- 内存开始地址
- 存在位（是否已调入内存）
同时记录共享此段的每个进程的情况。

1. 共享进程计数 `count`
非共享段仅为一个进程所有，当进程不需要此段时，可立刻释放此段，系统负责回收内存空间。而共享段为 **多个进程** 共享的，故当所有的共享该段的进程都不需要时，才会回收该段资源。

> 类似于 C++ 11 中的 `shared_ptr`

2. 存取控制字段
对于一个共享段，可以赋予不同的进程以不同的存取权限。例如对于文件主，允许其读写；而对于其他进程，则可能只允许读，甚至只允许执行。

3. 段号
对于一个共享段，不同的进程用 **不同的段号** 去共享该段。因为各个进程有不同的段表，其中的逻辑段号可能是不同的。

## 共享段的分配和回收

![](./image/20160714142039963)

### 共享段的分配

对于第一个请求使用该共享段的进程，由系统为该共享段分配内存资源，同时将该内存地址的开始地址写入 **请求进程** 的 **段表** 的相应表项中。

然后，还需要在共享段表中添加一表项，填写有关数据，置 `count` 为 1。

> 每个进程都有一个段表。所有进程由系统维护 **一个** 共享段表。当然，段页式存储中，每个段有一个页表，即每个进程可以有多个页表。

之后，当其他进程需要调用该共享段时，无需再分配内存资源，只需要在 **调用该共享段的进程的段表** 中添加一表项，写上该共享段的物理地址。由此可见，不同进程维护不同的段表，其段号是逻辑的，故不同的进程中的共享段的段号一般不同。

此外，还应在共享段中，填上该调用进程的进程名、存取控制等。再自增 `count` 字段。

### 共享段的回收

当共享此段的进程不再需要该段时候，应该将该段释放，包括撤销该进程的段表中共享所对应的表项，同时在共享段中执行 `count--` 操作。

若 `count` 之后为 0，则由系统回收该共享段的内存资源，并在共享段表中撤销该共享段。

否则，只是取消调用者进程的段表中的表项和共享段中的关于该调用进程的记录。


## 分段保护

分段存储管理中，由于每个段在 **逻辑上是独立的**。因此给信息保护提供了可能性。

1. 越界检查

该方法在分页存储管理中也使用。通过界限寄存器检查访问是否越界。同时，分段系统中还存在不同之处。即 **段表寄存器** 中存放着 **段表长度** 信息。同样的，**段表** 中也为每个段设置了 **段长**字段。

在进行存储访问时，首先检查 **段表寄存器中的段长** 和 **逻辑地址中的段号** 进行比较。如果段号大于段长，说明越界了。

其次还会检查，**段表中的段长** 和 **逻辑地址中段内地址** 是进行比较，如果偏移地址大于段长，也会越界。

```
// 段表寄存器
|   段表开始地址    |   段表长度    |

// 段表结构
|    段号    |   段长    |   段在主存中的开始地址   |

// 逻辑地址
|   段号    |   段内地址 offset |
```

2. 存取控制检查

在段表的每个表项中，都设置了一个『存取控制』字段：
- 只读 read-only
- 只执行，即只允许进程  **调用该段去执行**，但不允许读写该段的内容
- 读/写

一般来说，存取控制对于共享段而言比较重要，对不同的进程赋予不同的权限，既要保证信息安全，也要满足共享需求（运行需要）。

3. 环保护机构

见 https://blog.csdn.net/dongyanxia1000/article/details/51735099
