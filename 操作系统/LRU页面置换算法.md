# LRU 页面置换算法为什么需要寄存器和栈支持？

> LRU 为什么是堆栈类算法？

LRU 是基于局部性原理，根据一个作业在执行过程中过去的行为来推测未来的行为。LRU 认为过去最近一段时间不曾被访问的页面，在最近的未来也不会被访问。LRU 区别于最佳置换算法（理想的算法），因为最佳算法是已知未来的使用情况来作出判断，以置换哪个页面。当然这是不现实，系统无法预知未来。

LRU 置换算法需要记录各个页面使用时间的先后顺序，有两种可能的实现方法。

1. 系统维护一个页面链表，最近刚使用的页面作为首结点，最久未使用的页面作为尾结点，每次访问内存时，找到相应的页面，把它移到链表的首部，每次缺页中断，淘汰尾部的页面。
2. 维护一个页面堆栈：当访问某页时，将其移到栈顶。当缺页中断时，总是淘汰栈顶元素。

## LRU 的硬件支持

1. 寄存器

为每个在内存中的页面配置一个 **移位寄存器**，用来记录某进程在内存中使用各页的使用情况。移位寄存器表示为

$$
    R = R_{n-1}R_{n-2}\ldots R_1R_0.
$$

当进程访问某个物理块时，要将相应的寄存器的 $R_{n-1}$ 位置为 1；同时，**每隔一定的时间** 将寄存器右移一；如果把 $n$ 位寄存器看作一个整数，那么具有最小数值的寄存器所对应的页面，就是 **最近最久未使用的页面**，即淘汰页面。

2. 栈

系统利用一个栈来保存当前使用的各个页面的页面号。每当进程访问某页面时，便将该页面的页面号从栈中移到栈顶（同上面的介绍）。

**例子**：
| 物理页面 |   2   |   3   |   2   |   1   |   5   |   2   |   4   |   5   |   3   |   2   |   5   |   2   |
| :------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 物理块1  |   2   |   2   |       |   2   |   2   |       |   2   |       |   3   |   3   |       |       |
| 物理块2  |       |   3   |       |   3   |   5   |       |   5   |       |   5   |   5   |       |       |
| 物理块3  |       |       |       |   1   |   1   |       |   4   |       |   4   |   2   |       |       |
| 是否缺页 |  是   |  是   |       |  是   |  是   |       |  是   |       |  是   |  是   |       |       |

缺页 7 次，总访问次数 12 次。


LRU 是堆栈类算法，理论上不会出现 Belady 异常。当然，只有 FIFO 页面置换算法才会出现 Belady 异常。
