# B 树

1. B-tree 也是一种自平衡的树。二叉树查找树，查找的时候有两个分支，而 B-tree 有多个分支。
2. B-tree 的定义
    - 每个节点至多有 m 个子树（m 个分支，同时意味着其关键字个数至多为 m-1 个）
    - 若根节点不是叶子节点，则至少有两个子树，即 1 个关键字
    - 根节点之外的所有非叶子节点的子节点个数为 `[ceil(m/2), m]` （即关键字个数为 `[ceil(m/2)-1, m-1]`
    - 每个非叶子节点包含以下数据（n,A0,K1,A1,K2,...,Kn,An）：
        - Ki 为关键字，关键字是递增排序的
        - Ai 是指针，指向子节点
    - 所有子节点都在同一层

## B-tree 和二叉树（二叉搜索树）的不同

> 二叉搜索树可以『简单视为』B-tree 的特殊情况。

1. 二叉树
    - 每个节点最多 2 个子节点
    - 每个节点的 key 只有一个
2. B-tree
    - 所有的子节点都在同一层
    - B-tree 更加平衡，称为多路平衡查找树

## B-tree 的插入删除等操作

1. B-tree 的插入操作需要分裂合并破坏 B-tree 规则的节点

# B+ Tree

B+ Tree 是 B-tree 的升级版，一般来说，B-tree 也可以用作数据库的索引结构。而 B+ tree 比 B-tree 的查询性能更高，节点利用率更高。

1. B+ tree 的定义
    - 有 k 个子节点的节点必有 k 个关键字
    - 所有叶子节点保存了全部元素的信息，以及指向这些元素记录的指针
        - 叶子节点按照关键字大小顺序连接 （故 B+ tree 可以很方便遍历整个数据）
    - 所有中间节点的元素数据都存在于子节点中，在子节点中是最大/最小的元素

2. 卫星数据是什么？

卫星数据指的是索引元素所指向的数据记录。比如数据库的某一行。而在 B-tree 中，无论中间节点和叶子节点都带有卫星数据。而在 B+ tree 中，只有叶子节点带有卫星数据，其余节点仅仅是索引作用，没有任何数据关联。

最简单的情况下，卫星数据可以和关键字相同。大多数情况下，关键字远远小于数据本身，即 key 和 data 的区别。这点还是很容易理解的。

## 聚集索引和非聚集索引

> 聚集索引也成为聚簇索引，<font color="bule">应当注意数据库中的聚簇存取方法指的是将某些元素物理上聚集在一起。 </font>
1. 聚集索引指的是，所有卫星数据包含在叶子节点中
2. 非聚集索引指的是，所有叶子节点保存的是指向卫星数据的指针。

## 查询性能为什么更优？

由于 B+ tree 中的非叶子节点，不包含卫星数据，只包含指向子节点的指针，所以同样大小的磁盘也可以容纳更多的节点元素。这就是说，数据量相同的情况下，B+ tree 的结构更加“矮胖”，因此查询 I/O 次数更少。

简单来说，即每个非叶子节点存储的关键字更多，层次更少，I/O 次数更少。

## 查询性能更加稳定？

B+ 树的查询必须查到叶子节点，而 B-tree 由于非叶子节点也存储了卫星数据，故而不一定查到叶子节点。

## B+ tree 可以范围查找

B-tree 的范围查询必须中序遍历。而由于 B+ 的叶子是顺序链表的形式，所以只需简单的遍历即可。

## B+ tree 的插入和删除

大同小异。

# B+ tree 相比于 B-tree 的优点

1. 层次更少，每个非叶子节点存储的关键字更多，I/O 次数更少
2. 查询速度更加稳定
3. 可以范围遍历，或全局遍历（叶子节点是链表形式连接起来的）

# 散列表

Hash 的实现之一：维持一个数组（可以静态，可以动态，如 STL 用 vector），每个元素是一个指针，指向一个链表。

如果查找 key 为 K，我们通过计算 hash(K) 来找到桶号。为了提高效率，桶数组每个元素可以存储一个存储块，即不是单个指针。如果超过桶的大小，则连接到溢出块中。

## 效率

数据库也可以通过 Hash 表作索引。

1. rehash 是非常耗时的
2. hash 值计算也是耗时的
3. hash 内存效率很低

# 索引

为了加快检索速度的数据结构。

采用 B+ tree 的索引可以：

1. 索引可以大大减少需要扫描的数据量
2. 索引可以将随机 I/O 变成顺序 I/O
3. 可以避免排序（采用 RB/B-/B+ tree 树时）

## 索引的缺点

1. 更新索引的开销是较大的，因而频繁的插入、删除等操作性能会收到较大影响
2. 索引是占用空间的，组合索引会引起索引文件的大小快速膨胀
3. 数据量小的情况下，建立索引可能会更慢

## 单列索引、复合索引

1. 只包含一个字段的索引（单个列）---单列索引
2. 包含多个字段的---复合索引

``` sql
create [unique][cluster] index <索引名>     -- 其中 unique 表明建立的是唯一索引，cluster 是聚簇索引
on 表名(列名X[ASC|DESC]，列名Y[ASC|DESC]，列名Z[ASC|DESC]); -- 对于顺序索引而言，默认 ASC 
```

该语句相当于建立了三个索引，分别是

1. 单列索引（列X）
2. 复合索引（列X，列Y）
3. 复合索引（列X，列Y，列Z）

> 类似于 姓-名-电话号码

电话簿中的内容先按照姓氏的拼音排序，相同姓氏再按名字的拼音排序，这相当于在（姓，名）上建立了一个复合索引。你可以通过这个索引快速找到所有具有特定姓氏的人的电话号码，也可以快速找到具有特定 姓-名 组合的人的电话号码。然而，想象一下，如果你想找到某个特定名字的人，其实这个索引是没有用的，你只能从头到尾遍历整个电话簿。

## 唯一索引 和 主键

1. 唯一索引：在表上一个或多个字段组合建立的索引，这些字段在表中具有唯一性。一个表可以建立任意多个唯一索引，但是一般只建立一个

2. 主键是一种特殊的唯一索引

区别：

1. 唯一索引允许某个字段为 null 值，但是最好不要；主键中的字段不允许为 null 值
2. 唯一索引可以有多个，关键字/主键索引只有一个

# 聚簇索引、非聚簇索引、主键

> https://blog.csdn.net/lm1060891265/article/details/81482136

MySQL 的 InnoBD 引擎，底层使用 B+ tree 实现的索引结构：分为聚簇索引、辅助索引（非聚簇索引）

InnoDB 中的主键索引是一种聚簇索引，非聚簇都是辅助索引，如复合索引、前缀索引、唯一索引

InnoDB 使用聚簇索引，MyISam 使用非聚簇索引

## 聚簇索引

1. 聚簇索引：所有的数据都存储在叶子节点中

按照每张表的主键构造一个 B+ tree，如果没有定义主键，则选择一个『唯一的非空索引』代替。若没有，InnoDB 隐式创建一个主键。叶子节点存储了整个行的数据，也称为『主键索引』。因此，聚簇索引的顺序就是数据在硬盘中的顺序（不一定是物理连续），而且每个表只能有一个聚簇索引。

优点：

1. 访问更快，因为聚簇索引，将索引和数据都保存在了 B+ tree 的叶子节点，对于非聚簇而言，仍然需要通过主键的值再进行一次查询（二次索引）
2. 聚簇索引对于主键的排序查找和范围查找更快

缺点：

1. 插入速度严重依赖于插入顺序，按照主键的『顺序插入』是最快，否则出现『页分裂』，严重影响性能。因此，对于 InnoDB，一般都会定义一个自增的 ID 列为主键
    - 聚簇索引的数据是相邻的，那么对应的磁盘上的位置也是相邻的，如果主键不是自增的 ID，将会不断调正数据的物理地址、分页。数据存储将会很零散，不够紧凑，磁盘碎片多，效率低。
2. 更新主键的代价很高，因此将会导致被更新的行的移动。因此，InnoDB，一般主键定义为不可更新
3. **二级索引访问**需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据
    - 类似回表操作的例子

## 非聚簇索引

2. 非：所有的叶子节点只保存指向数据的指针，即叶子节点仍然是一个索引节点

在聚簇索引的基础上再创建一个索引。辅助索引总是需要二次查找。非聚簇索引的叶子节点存储的是主键值，然后再根据主键值进行二次索引，找到数据行的数据页，通过数据页找到数据行。

InnoDB 非聚簇（辅助）索引的叶子节点除了，包含主键值外，还包含了相应的行数据的聚簇索引键

MyISAM 的主索引就是非聚簇索引，那么他的数据的物理地址必然是凌乱的，那么这些物理地址，按照一定的算法进行 I/O 读取。

## 聚簇索引 和 唯一索引

聚簇索引不一定是唯一索引，聚簇索引的值不要求是唯一的，唯一聚簇索引才是。

# 索引一定会加快检索速度麽？

不一定。

1. 索引命中失败：如联合索引（a, b），查的时候， `where b = 3` ，则不会命中索引，则会全表扫描

> `where a = 3` 是会命中索引的

2. 过滤条件中包含 `in` ,    `or`

# 回表查询

1. 如果建立了创建了 (a,b) 索引 a_b_index，下列查询语句

``` sql
select * from table 
where a="..." and b = "...";
```

这里 a, b 命中索引后，数据库还有回到聚簇索引中查找其他数据，这就是『回表』，这也是少用 `select *` 的原因

# 索引覆盖

如上面的 a_b_index 索引，查询

``` sql
select a,b from table 
where a="..." and b="...";
```

此时，索引刚好都能获取到，不需要回表，满足索引覆盖

# 最左前缀原则

如索引 `a_b_c_index:(a, b, c)` 是字段 a, b, c 的联合索引，下列 SQL 执行时都无法命中索引

``` sql
select * from table where c = '1';
select * from table where b = '1' and c = '2';
```

而下列则可以命中

``` sql
select * from table where a = '1';
select * from table where a = '1' and b = '2';
select * from table where a = '1' and b = '2' and c = '3';
```

这是因为如前所述的，

``` sql
create index a_b_c_index on table(a,b,c);
```

相当于创建三个索引，即 (a), (a, b), (a, b, c)

特殊情况：

``` sql
select * from table where a = '1' and b > '2' and c = '3';
```

这里的 sql，在 a、b 索引走完之后，c 已经是无序的，因此 c 没有走索引，因此 c 需要全表扫描

# 索引 和 SQL 优化

1. `like "%abc%` 不会使用索引
2. `like "a%` 可以使用索引：命中索引 (a)，返回所以以 `a` 开头的数据
3. `not in` 和 `<>` 不属于支持的范围查询条件，因此不会使用索引
4. 复合索引中只要有一列为 null，则这一列对于此复合索引是无效的，因此尽量不要使用 null
5. 不要在字段上进行计算，如 `select * from table where year(field1) < 2017` 这样就不会使用索引

# 事务

一个操作序列，具有原子性。是并发控制的基本单位。事务是维护数据一致性的基本单位。

1. 原子性。
2. 一致性。只有合法的数据才可以写入，否则事务回滚到最初的状态
    - 比如一个一个课程表和一个教师表，向课程表中插入一个教师表中没有的教师
3. 隔离性
    - 允许多个用户对同一个数据并发访问（因为事务具有原子性），可以保证类似线程安全的概念。从而不破坏数据的正确性和完整性。
4. 持久性。事务结束后，事务处理的结果必须能够固化，对数据库的影响是永久的，真实的修改了数据库

这 4 个属性简称 ACID 特性。

# 事务 和 SQL

1. 一条事务可以是一条 SQL 语句、一组 SQL 语句，或整个程序

# 数据库的 乐观锁 和 悲观锁

1. 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作
2. 乐观锁：假定不会发生并发冲突，只有在提交操作时，检查是否违反了数据完整性

前者对并发操作的事务进行加锁。只有该事务执行完，释放锁。

缺点：

1. 一定的开销，增加了系统负载
2. 一定程度上降低了并行性，其他事务必须等待其释放资源才可以操作

后者在事务操作的最后提交过程前，检查是否其他事务是否有更新，有的话，则进行回滚。

# 基本概念

1. 超键：可以唯一标识一个记录（行）的字段组
2. 主键：超键去掉冗余部分，即是候选键：候选键中的属性多一个不多，少一个不少。

如字段组 `(a,b,c)` 可以唯一标识一个记录，那他就是超键。如果去掉 `c` ，字段组 `(a,b)` 仍有可能唯一标识一个记录。而去掉 `(a,b)` 中任一一个都不可以唯一标识一个记录，那其就是候选键。

3. 主键：一个表有多一个候选键，选择其中一个作为主键，主键不可以为 null
4. 外键：一个表有另一个表的主键称之为外键

# 为什么建议使用自增 ID 作为主键？

如 MySQL 中的 InnoDB 引擎中，默认为聚簇索引，采用 B+ tree 数据结构实现。那么对于聚簇索引而言，顺序插入是最优的选择。而且聚簇索引中叶子节点的顺序就是数据物理存储的顺序。如果采用自增 ID，则新插入一个新纪录可以直接插在后续位置，如果一个 页 写满了，开辟一个新页即可。

如果使用，自定义主键，由于每次插入主键的值近似于随机，每次新记录的插入都要被插入到现有索引页中间的某个位置，这样 MySQL 必须先找到插入位置，再将新记录插到合适位置而移动数据，即调整大量数据的物理地址，分页等操作，数据存储将会比较零散造成大量的碎片。

# 存储过程

存储过程，是完成一个特定功能的 SQL 集。经过一次编译后，再次调用无需再次编译。类似于脚本。

对于重复性的工作，将实现其功能的 SQL 写好存储起来，因为称之为『存储过程』。

优点： 

1. 存储过程存储在数据库中，可以直接在服务器端的数据库运行，减少网络通信量
2. 一次编译，后续直接调用，而且一旦存储过程执行，内存中也会相应的保留一份，下次调用可以直接在内存调用
3. 可重复使用，这也是其最初目的之一
4. 安全性高，执行存储过程需要有一定权限的用户

因而速度快，效率高。

# 视图

一个虚拟的表，基于物理的表形成一个虚拟的表。

1. 定制用户数据，通过定制不同的视图
2. 简化数据操作，通过直接给出常用的视图
    - 将常用的，复杂的查询语句 可以直接创建一个视图 
    - `select * from view`
3. 数据有一定的安全性
    - 不直接把表的所有数据暴露给用户
    - 并且不可以随便修改真实表中的数据

# drop，truncate，delete

1. drop 删除表（结构和数据）
2. truncate 删除表中数据
3. delete 删除表中数据

* 速度：drop > truncate > delete
* 表被truncate 之后，表和索引所占用的空间恢复到初始大小

    delete 则不会减少表和索引占用的空间
    drop 直接删除表占用的所有空间

* delete 是 DML(DATA maintain language)，这个操作会放到 rollback segment中，事务提交后才生效
* truncate 和 drop 是 DDL(data define language)，操作立即生效，因此不能回滚

# char 和 varchar

1. char 的长度固定，varchar 可变
    - 如果插入的数据小于给定的长度，后面补0或空格，因此 char 类型需要使用 trim
    - varchar 则不需要

2. char 的空间可以换为时间效率，长度固体，方便程序存储和查找
3. 存储方式不同，

# SQL 语言分类

1. DQL: data query language 
    - `SELECT FROM TABLE_NAME [WHERE]`
2. DML: data manage language
    - `insert into table_name(...) values(...)`
    - `update table set ... [where]`
    - `delete ... from table [where]`
3. DDL: data define language 立即执行，不能回滚操作
    - drop
    - truncate
    - create
4. DCL: data control language
    - grant: 授权
    - revoke: 收回权限
    - commit: 事务提交
    - rollback: 事务回滚

# count(*), count(field), count(1)

* count(*) 计算行数，包含 null
* count(field) 计算某一个字段的行数，不包含 null
* count(1) 同 count(*)

# MySQL 三种引擎

1. InnoDB 支持事务，MyISAM 不支持，因此前者可以进行回滚操作
2. MyISAM 适合查询和插入为主的应用
    - 该场景下，性能更优，MyISAM 中主索引和辅助索引是独立的
    - 占用内存更少，索引更小
    - 数据和索引分开存储的
3. InnoDB 支持外键，后者不支持
4. InnoDB 支持行级锁和表级锁，后者只支持表级锁
5. InnoDB 默认聚簇索引，后者为非聚簇索引

# MyISAM 查询更优？

1. InnoDB 要缓存数据块和索引块，而 MyISAM 只需要缓存索引
2. InnoDB 寻址需要映射到块，再到行；MyISAM 记录的直接是文件的 OFFSET，定位更快

# 全表查询

1. 没有索引优化
2. 遍历所有的表记录

# 索引的优点

1. 加快检索速度
    - 不一定加快，如未命中索引
    - 小规模数据的时候，可能步入全表查询块
2. 加快表的连接速度

# 索引的缺点

1. 创建、更新索引非常耗时
2. 插入、删除、更新操作需要维护索引
3. 索引占空间
4. 有时候索引不如全表查询快，比如数据量小的时候

# 为什么使用 B+ tree 而不是 AVL、红黑树

1. B+ 树层次更低，意味着更少的 I/O 操作次数
2. B+ 支持范围检索
