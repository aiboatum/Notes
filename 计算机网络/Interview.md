# 如何区分大小端？

以 `unsigned int value = 0x12345678` 为例，我们可以用 `unsigned char buf[4]` 来表示value

1. Big-Endian: 低地址存放高位，如下：

~~~

高地址
　　---------------
　　buf[3] (0x78) -- 低位
　　buf[2] (0x56)
　　buf[1] (0x34)
　　buf[0] (0x12) -- 高位
　　---------------
低地址
~~~

2. Little-Endian: 低地址存放低位，如下：

~~~
高地址
　　---------------
　　buf[3] (0x12) -- 高位
　　buf[2] (0x34)
　　buf[1] (0x56)
　　buf[0] (0x78) -- 低位
　　--------------
低地址
~~~

3. 如何区分？

将每个字节取出来，就可以判断，代码如下：

```c++
#include <iostream>
#include <stdio.h>
using namespace std; 
int main()
{

    int x = 0x01234567; // 正好占 8 bit
    for (int i = 0; i < sizeof(int); ++i, putchar('\n')) {
        printf("%.2x", reinterpret_cast<char*>(&x)[i]);
    }
    if (reinterpret_cast<char*>(&x)[0] == 0x67) {
        cout << "Big endian" << endl;
    } else
        cout << "little endian" << endl;
    // 或者直接点
    int a = 0x1;
    if (*(char *)(&a) == 0x1)
        cout << "Big endian" << endl;
    else 
        cout << "little endian" << endl;

}

``` 

## TCP/UDP 的区别：

1. TCP面向连接，即传输数据前要先建立连接，UDP则不需要
2. TCP 提供可靠传输服务，UDP 则是尽最大努力交付服务
3. TCP 面向字节流，UDP 面向报文流，即 TCP 将应用层的数据看成无结构的字节序列，如果应用层传输的数据过长，将会存储在一个
    - TCP 中有个缓冲，当应用程序程序过长，则会把它划分短一些再传送。发送的状态也是按照字节流的方式发送的，和应用层传递下来的长度没有关系，故而称之为流。
    - UDP 将应用层的数据直接加上头部，直接交付给 IP，IP 层负责切片
4. TCP 是点到点传输；UDP 可以 一对多，多对一通信
5. TCP 是全双工的可靠逻辑信道，UDP 是不可靠的逻辑信道

## 端口对应的服务

```

ftp: 20 传输数据 21 传输控制数据
22 SSH
23 Talnet
25 SMTP
53 DNS
http: 80 https: 443
110 POP3
1080 SOCKETES

```

## TCP 三次握手

TCP 报文段包含：

1. 序号：seq，标识发送字节流的序号，以保证按序交付
2. 确认号：ack，ack标识位为1，ack的值才有效，ack = seq + 1，即对 seq 的确认
3. 标志位：ACK,SYN,FIN
    - ACK:确认序号有效
    - SYN：发送一个新连接
    - FIN：释放一个新连接

> 确认序号ack 和 标志位的 ACK 不可搞混

1. 客户端发送一个TCP报文，包括 SYN=1,seq=x，进入 SYN-SENT 阶段
2. 服务端处于 LISTEN 阶段，收到 TCP 报文后，结束 LISTEN 阶段，返回一个TCP报文
    - SYN=1，ACK=1,seq=y,ack=x+1（确认客户端发送的序号为x的字节序列收到）

    随后进入 SYN-RCVD （表示 SYN RECEIVED）

3. 客户收到服务器的确认的 TCP 报文后，结束 SYN-SENT 阶段，返回一个 TCP 报文
    - ACK=1（确认收到服务器的确认报文）,seq=x+1,ack=y+1

    随后进入 ESTABLISHED 阶段

4. 数据传送阶段

客户端是主动打开的，调用connect()；服务端被动监听，调用listen()

## TCP 四次挥手

同理，TCP 四次握手时，客户端主动关闭TCP 连接，想服务器发送一段TCP 报文，其中

* FIN=1，表示请求释放连接
* 序号为 seq=u

随后进入 FIN-WAIT-1 阶段，即半关闭阶段。客户端停止向服务端发送数据，但是客户端仍可接收服务端的数据。

> 发送端，不可发送的是正常连接时，传送的数据（非确认报文），而不是一切数据，所以客户端仍可向其发送 ACK 确认报文

服务端收到客户端发送的“请求释放连接“的TCP报文之后，确认了客户端想要释放连接，随后服务器端结束 ESTABLISHED 阶段，
进入 CLOSE-WAIT 阶段（半关闭阶段）并返回一段 TCP 报文，其中

* ACK=1，表示收到客户端发送的释放连接的请求
* seq=v
* ack=u+1

随后服务器端开始释放连接

客户端收到服务端的 TCP 报文后，确认了服务器收到了客户端发出的释放请求，随后客户端结束 FIN-WATI-1，进入 FIN-WAIT-2 阶段

> 前两次挥手，既让服务器端知道了客户端想要释放的连接，也让客户端知道了服务器端收到了自己的请求，于是可以确认关闭客户端到服务器方向上的连接了

服务器端自从发送 ACK 确认报文之后，经过 COLSED-WAIT 阶段，做好了释放准备，再次向客户端发送一段 TCP 报文，
其中，

* FIN=1, ACK=1 表示已经准备好释放连接了 
* seq = w
* ack = u+1, 

客户端收到TCP报文后，确认了服务端做好了释放准备，结束 FIN-WAIT-2 阶段，进入 TIME-WAIT 阶段，并向服务器发送一段报文，其中

* ACK=1，表示”接收到服务器准备释放连接的信号“
* seq = u + 1
* ack = w + 1

客户端在 TIME-WAIT 等待 2MSL（TCP 报文在传输过程中的最大生命周期）：为了确认服务器端是否收到客户端发出的 ACK 确认报文

服务器接收到 TCP 报文后接收 LAST-ACK 阶段，进入 CLOSED 阶段。由此确认关闭连接。

客户端等待 2 MSL 之后，进入 CLOSED 阶段

5. 为什么客户端在TIME-WAIT阶段要等2MSL?

为的是确认服务器端是否收到客户端发出的ACK确认报文

当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。

服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文；

如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；
否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。

所以，客户端要经历时长为2SML的TIME-WAIT阶段；这也是为什么客户端比服务器端晚进入CLOSED阶段的原因

4. 为什么“握手”是三次，“挥手”却要四次？

TCP建立连接时之所以只需要"三次握手"，是因为在第二次"握手"过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文。

即SYN建立连接报文与ACK确认接收报文是在同一次"握手"当中传输的，所以"三次握手"不多也不少，正好让双方明确彼此信息互通。

TCP释放连接时之所以需要“四次挥手”, 是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次"握手"传输的。为何建立连接时一起传输，释放连接时却要分开传输？

建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。
释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。

所以是“三次握手”，“四次挥手”。

# IPV4/IPV6 的区别？

1. IPV4 32bit;后者 128bit
2. IPV6 路由更小，转发速度更快
3. IPV6 强制要求 IP 报文层的加密
    - IPSEC 就是为 IPV6 而生，但是 IPV4 就应用了
    - 现在 IPSEC 不是强制要求，但是 IPV6 必须保证 IP 层的加密和认证需求
4. 自动配置：IPV6 只有加入网络，即可自动完成网络配置，不需要手动配置或 DHCP

# IPV6/IPV4 如何转换？

1. 双协议栈
    - 同一主机有两个协议栈
        - IPV4 走。。。
        - IPV6 走。。。
2. 隧道协议
    - 将 IPV6 报文封装成 IPV4 报文

# HTTP

略...

# HTTPS 和 HTPP 的区别

1. HTTPS 加上了 SSL 层（安全套接字层），即对 HTTP 报文添加了加密和认证机制
2. 端口不同：80；443
3. HTTPS 由于添加了加密和认证机制，消耗 CPU 和内存资源更多，通信量更多

# IP 报文的最大长度是多少？

IP 报文的最大长度，由 frame 的最大长度决定。

而以太网 frame 的最小长度为 64B，这是由于早期的 CSMA/CD 载波聚合/冲突检测的机制导致的，每个节点发送数据前都要先监听是否有人占用了该信道。而且需要在发送过程中，需要可以检测到冲突碰撞产生的情况。一来一回，需要两个 time slot，大概是 57.6 μs，在 10Mbs 的线路上，为 64B。

而最大长度是 1518B，是一个折衷值。
