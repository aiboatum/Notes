# 应用层

应用层是直接与用户打交道的。

## 应用程序体系结构

1. C/S 体系结构：如 web 服务器响应浏览器的请求
    - 服务器的 IP 地址一般是固定的，服务器是一直运行的
2. P2P 体系结构：如文件共享（BitTorrent），对等方协助下载加速器（如迅雷），因特网电话（Skype）和 IPTV（迅雷看看，PPstream）
    - 对数据中心的专用服务器有着最小（或没有）依赖，区别于 C/S 体系结构
    - 端对端直接通信，一般不通过中继的服务器，因此被称为对等方。
3. 混合体系结构：如即时通信，服务器用于跟踪用户的 IP 地址，但用户到用户的报文在用户主机之间直接发送（无需通过中间服务器）

## 进程通信

端系统中进行通信的，按照操作系统术语来说，是**进程**，每个进程占用一个端口进行通信，当然具体通信规则每个端系统是不同的。

> 同一个主机的不同进程也需要通信。但不属于网络通信范畴内。

应用层的数据称之为**报文（message）**。进程就是通过计算机网络交换报文进行通信。

### 客户和服务器进程

Web应用程序中，一个客户浏览器进程与一台web服务器进程交换报文。在P2P文件共享系统中，文件从一个对等方的进程传输到另一个对等方的进程。

1. 每队通信进程，分别标识为**客户**和**服务器**：
    - web 而言，浏览器为客户进程，web 服务器为服务器进程。
    - p2p 文件共享，下载文件的对等方为客户，上载的为服务器。

2. 进程与计算机网络之间，通过被称之为**套接字（socket）**软件接口进行发送报文和接收报文。
    - 套接字也称之为应用程序和网络之间的 API，应用程序可以控制套接字在应用层端的一切，但是对其传输层的行为没有控制权限。应用程序有以下控制权：
        1. 选择运输层协议（TCP 还是 UDP 等）
        2. 设置某些运输层参数，传递给运输层，如最大缓存，最大报文段（运输层的数据单位）长度等。

3. 进程寻址：一台主机的进程和另一个主机的进程通信，有以下信息标识各自的地址，
    1. 主机的地址（IP 地址标识）
    2. 进程在主机中的标识符（如双方约定好的端口号）

### 可供应用程序使用的运输服务

运输层提供不同的服务可供应用程序使用。类似于两个城市之间可以坐火车或坐飞机等交通工具。

有如下服务：

1. 可靠数据服务： 该服务确保应用层接收到的是完全无差错的数据。发送进程只要将其数据传递给套接字，就可以完全相信该数据可以完全无差错的到达接收进程。
    - 一些应用可以容忍一定的丢包等数据丢失，如音频/视频等。可以不必采用可靠数据服务。
2. 吞吐量： 两个进程之间的数据比特发送和接收的速率。
    - 运输层协议可以确保一个最低吞吐量，例如因特网电话程序对语音以32kbps的速率编码，那么运输层必须以不低于这个速率向网络传输数据，如果不能提供这种吞吐量，该应用程序或以较低速率进行编码，或可能放弃本次发送。这是因为因特网电话而言，接收所需吞吐量的一半几乎没有任何用处。此类对吞吐量有要求的应用称之为**带宽敏感的应用**。
3. 定时：运输层可以提供定时服务，常用于实时应用。
4. 安全性：如是否加密，是否检测完整性等等。

### TCP/UDP

TCP 服务：

* 面向连接的服务，即端到端之间先建立连接

  

* 可靠的数据传送服务，即无差错，按适当顺序（不是乱序）交付发送的数据，具体为数据（字节流）传递给套接字，运输层TCP将相同的字节流交付给接收方的套接字，没有字节丢失和冗余。

  

* 拥塞控制服务

UDP服务：无连接，无保障的服务，不提供拥塞控制，基于 UDP 的应用层协议也可以通过自己控制，来实现可靠的数据传送服务

> 然而因特网协议即 TCP/UDP 协议不提供定时和吞吐量服务，应用层在 TCP 的基础上可以使用 [SSL](https://baike.baidu.com/item/ssl/320778?fr=aladdin)，以提供安全性。今天的因特网通常可以为保障时间敏感应用提供满意的服务，但不能提供任何定时或带宽要求。

## 应用层协议

``` c
SMTP  电子邮件 TCP
Telnet/SSH 远程终端访问 TCP
HTTP web服务    TCP
```

应用层协议定义了（指明不同端系统的应用程序如何相互传递报文和理解报文）：

* 交换的报文类型，如请求报文和响应报文
* 报文的语法，格式等，如报文中的各个字段如何描述
* 各个字段的语义，即各个字段代表什么含义
* 进程何时发送，如何发送，如何相应等规则

### HTTP 

> 应当指明，这些应用层协议中，最常用也是最经典的协议就是 HTTP 协议。

HTTP (HyperText transfer protocol)，即超文本传输协议。客户端和服务段通过 HTTP 报文进行通信。

#### Web 和 HTTP

1. web page（web 页面），或文档，由对象构成：对象如 HTML 文件、JPEG 图像、一个视频片段等
2. 用户代理 user agent：浏览器，不同的浏览器实现的 HTTP 的客户端

#### HTTP 的工作流程

WEB 服务的核心基于 HTPP 协议，HTTP 协议基于传输层 TCP 协议。HTTP 客户首先发起一个与服务器的 TCP 连接。一旦连接建立，该浏览器进程和服务器进程就可以通过套接字（Socket)接口访问 TCP。客户端通过它的套接字接口发送 HTTP 请求报文并从它的套接字接口接收 HTTP 响应报文。当然，服务器也是这个流程。一旦客户向它的套接字接口发送一个请求报文，该报文的控制就交由 TCP。

HTTP 协议基于 TCP，因此不必担心 HTTP 请求/响应报文不会到达客户/服务器段。

HTTP 协议是一个『无状态协议』，即 HTTP 服务器不会保存关于客户的任何信息，即某个客户短时间内多次请求同一个对象（向同一个服务段发送 HTTP 请求报文），服务器都是将该请求看作一个全新的请求。

许多因特网应用中，客户和服务器在相当长的一个时间内通信，其中客户发出的一系列请求并且服务器对每个请求进行响应。这一系列请求可以以规则的间隔周期性地或间断性地一个接着一个发出。当这种 C/S 交互是通过 TCP 进行的，那么就有两个选择，即

* 每个请求/响应对是经一个单独的 TCP 连接发送
* 所有的请求及其响应经相同的 TCP 连接发送

  

##### 非连续连接的 HTTP

假设我们有一个 HTML 文件的 URL 为： `http://www.someSchool.edu/someDepartment/home.index`
1. HTTP 客户进程在端口号 80（HTTP 默认端口）发起一个到服务器 `www.someSchool.edu` 的 TCP 连接，客户和服务器端都有一个套接字和该 TCP 连接相关联  --- 建立 TCP 连接

2. HTTP 客户经它的套接字向该服务器发送一个 HTTP 请求报文，该请求报文中包含路径名 `/someDepartment/home.index`
    1. 客户端发送请求命令，如 `GET ...`
    2. 客户端发送请求头信息，如请求获取资源的路径名
    3. 发送一段空白行标识该头信息结束

3. HTTP 服务器进程经它的套接字接收该请求报文，从服务器的存储中检索出对象 `www.someSchool.edu/someDepartment/home.index` ，在一个 HTTP 响应报文中封装对象，并通过其套接字向客户发送响应报文
    1. 返回 HTTP 响应，如 `HTTP/1.1 200 ok` 到客户端
    2. 返回响应头信息到客户端
    3. 发送数据到客户端

4. HTTP 服务器进程通知 TCP 断开该 TCP 连接。（**但是，直到 TCP 确认客户已经完整的接收响应报文为止，其才会实际中断 TCP 连接**）

5. HTTP 客户从套接字接口中接收响应报文，TCP 连接关闭（TCP 协议负责关闭）。该报文指出封装的对象是一个 HTML 文件，客户从响应报文中提取出该文件，检查该 HTML 文件，得到 10 个 JPEG 图像的引用

6. 对每个引用的 JPEG 图像重复前几个步骤

> 如何解释一个 WEB PAGG，和 HTTP 没关系。这个由其他负责。

由此可以看到，对于这样一个请求场景，用户请求该 web page（包含 11 个对象），要产生 11 个 TCP 连接。然而对于每一个 TCP 连接而言，都涉及到“三次握手”的过程，该过程前两个部分花费一个 RTT，最后一个部分是服务器发送响应报文的时间。

##### 持续连接的 HTTP

   
服务器在发送响应后保持该 TCP 连接打开，相同的客户和服务器之间的后续请求/响应报文通过相同的 TCP 连接进行通信。如一个完整的 web page（如包含一个 HTML 文件和 10 个图形文件）可以用单个连续的 TCP 连接进行传送。更有甚者，位于同一台服务器的多个 web page 从该服务器发送给同一个客户时，可以在单个持续的 TCP 连接上进行。

一般来说，如果一个 TCP 连接在一定的时间间隔内没有被使用，HTTP 服务器就关闭该 TCP 连接。

> HTTP 默认的模式就是这种

#### HTTP 报文

1. HTTP 报文格式

```
GET /somedir/page.html HTTP/1.1     -- HTTP/1.1 表示 HTTP 协议版本
Host: www.someschool.edu
Connection: close                   -- 是否使用持续的 TCP 连接
User-agent: Mozilla/5.0             -- 用户代理，即向服务器发送请求的浏览器的类型
Accept-language: fr                 -- 服务器应当返回对象的法语版本
```   

2. 响应报文基本上类似

### 引入 cookie

由于 HTTP 服务器是无状态的。这对于服务器的设计是有利的，因为简化了功能。然而，web 站点一般希望能够识别用户，可能是因为服务器希望限制用户的访问，或者因为它希望把内容与用户身份联系起来。为此，HTTP 引入了 cookie。

> 目前，绝大多数网站都使用了 cookie
cookie 包括四个组件：
1. HTTP 响应报文的一个 cookie 首部行
2. HTTP 请求报文中的一个 cookie 首部行
3. 用户端系统中保留一个 cookie 文件，由用户的浏览器进行管理（用户代理）
4. 位于 Web 站点的一个后端数据库

#### cookie 是什么？

1. cookie 是浏览器访问服务器后，服务器传给浏览器的一段数据
2. 浏览器需要保存这段数据，不得轻易删除
3. 此后每次浏览器访问该服务器，都必须带上这段数据

#### cookie 的作用是什么？

识别用户身份和识别身份：被设计用来保存一些站点的用户数据，这样能够让服务器为这样的用户定制内容。页面代码能够获取到Cookie值然后发送给服务器，比如Cookie中存储了所在地理位置，以后每次进入地图就可以默认定位到改地点。比如打开一个购物网站，将 A1,A2 加入购物车后；过两三天再打开网页的时候，（如果该cookie没有被删除），依然可以看到A1,A2在购物车中。


#### cookie 的问题

- 多个用户公用一台电脑比如网吧，那么前一个人登陆购物网站并购买物品，后一个人可以使用前一人的账号进行购物。清除浏览器缓存等操作可以擦出掉Cookie，因而很难恢复之前做过的操作，要查看添加到购物车商品几乎不可能。
- 多太电脑之间的网站浏览记录（这里不是浏览器的历史记录）会不一致，比如这台电脑某宝告诉你你浏览过某些商品，另一台电脑可能是另外一些商品，因为不同 Cookie 对应的不同浏览记录。这也是为什么需要使用账号登陆的原因，只要登陆过就能把所有记录跟后台数据库中的账号强关联起来。

### web 缓存器

web cache，也叫代理服务器。其实就是客户端到服务器端的一个
cache，和计算机内部的 cache 本质上是相同的。web cache 保存用户最近请求访问过的对象的副本。过程简述如下：
- 浏览器建立一个到 web cache 的 TCP 连接，并向 web cache 中的对象发送一个 HTTP 请求
- web cache 检查本地是否有该对象的副本，如果有，web cache 返回 HTTP 响应报文；如果无，则该 web cache 再建立和服务器端的 TCP 连接，向其发送一个 HTTP 请求，然后服务器返回 HTTP 响应报文给 web cache，web cache 则保留该对象的副本，并向客户的浏览器返回 HTTP 响应报文的副本

web cache 的意义在于：
1. 较少客户的响应时间
2. 整体上大大减少因特网上的 web 流量
