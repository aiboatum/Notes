# 内存对齐

> [内存对齐详解 CSDN](https://blog.csdn.net/qq_31821675/article/details/72853551)

对齐，即数据在内存中的位置相关。如果一个数据的内存地址（其偏移量）正好是其数据长度的整数倍，称之为『自然对齐』。比如，在 32bit 的系统下，一个 int 变量的地址为 0x00000004，即其是『自然对齐』的。

## 为什么需要对齐

1. 为了 CPU 访问数据的效率。

如果一个 32bit 系统中，int 变量位于 0x00000002。即占据 0x00000002-0x00000005，四个字节位置。

则 CPU 取值需要两次内存访问，第一次取从 0x00000002-0x00000003 的一个 short，第二次取 0x00000004-0x00000005 的一个 short，然后组合。如果变量位于 0x00000003-0x00000006，则需要三次访问，第一次为 char，第二次为 short，第三次为 char，然后组合得到数据。

如果变量是自然对齐的位置，则可以一次就取出数据。

> 一些特别的系统，对于对齐要求比较严格，比如 sparc 系统（没听过...），如果未对齐则会发生错误。

```c++

char ch[8]; // 8 个字节
char *p = &ch[1]; 
int i = *(int *)p; 

``` 
2. 为了内存利用率

## 如何对齐

1. 标准类型，它的地址是其长度的整数倍即可。
2. 非标准类型，规则如下：
    - array，按照基本类型对齐，第一个对齐，则后续的元素显然也是对齐的
    - union，按其包含的长度最大的数据类型对齐
    - struct，每个数据都要对齐

## struct 对齐规则

1. 数据类型的对齐值，即 `char` 占一个字节，其 offset 应该是 1 的倍数， `int, float, double` 等 offset 应该为 4 的倍数【称之为对齐值】
2. 结构体或类的对齐值：成员中自身对齐值的最大的那个值
3. 指定对齐值： `#pragma pack(n)`
4. 有效对齐值：Min{自身对齐值,指定对齐值}

```c++
struct abc{
    char a;
    int b;
    short c;
};
sizeof(struct abc) == 12
```

在 X86-64 系统下，GCC 默认按 4 字节对齐。因为，其对齐大致如下：

* a 的 offset 为 0，占据 1B
* b 的 offset 为 1，但是 b 的长度为 4 字节，故其 offset 应该为 4 的倍数，因此填充 3B，自己本身占 4B
* c 的 offset 为 8，因而无需填充字节，自己本身占据 2B
* 整个结构体的长度为 1+3+4+2=10 字节，该长度应该为 『结构体中类型最大长度』的倍数，因此填充 2B

故总共占 12 字节。

当然，下面的结构按照默认 4 字节对齐对齐时，为 8B。
```c++

struct abc{

    int a;
    char b;
    short c;

}; 
sizeof(struct abc) == 4 + 1 + 1(填充字节) + 2 = 8

``` 

## 更改默认对齐规则

```c++
#pragma pack(n)     // 按 4 字节对齐
#pragma pack()      // 取消自定义字节对齐
struct tmp{

}__attribute((aligned(n))); // 所有的 tmp 的成员对齐在 n 字节的自然边界上。
                            // 如果结构体中有成员长度大于 n，则按照最大成员的长度来对齐
__attribute((packed));      // 取消对齐优化，按照实际占用字节数进行对齐
```

1. 对于下面的结构体

```c++
struct tmp{

    char a;
    int b;
    short c;

}; 
sizeof(struct tmp) == 12B
#pragma pack(1) 时，占 1 + 4 + 2= 7B
#pragma pack(2) 时，占 1 + 1(填充) + 4 + 2 = 8B 
```
