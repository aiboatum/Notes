# C 内存类型

1. 堆区：malloc/free【操作方式是链表形式】
2. 栈区：局部变量、形参【操作方式类似于数据结构中的栈】
3. 程序代码区：存放二进制的代码
4. 全局/静态存储区：全局变量，static 变量【会被初始化】
5. 常量存储区/文字常量区：const，字面值常量【程序结束，OS 负责回收资源】
6. C++ 中 new 的是自由存储区

# 堆栈的区别（区别于数据结构中的堆栈）

1. 堆区存放动态分配的资源，需要程序员手动释放，或者由系统释放
2. 栈区存放局部变量和函数参数值，程序控制栈区资源的生命周期（程序自动分配资源和释放），操作方式类似数据结构中的栈

申请资源方式的差异：

1. heap:程序员指定大小；stack 系统自动分配
2. heap 申请时，操作系统有一个记录空闲内存的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的『堆节点』，然后将该节点从空闲节点链表中删除该节点，并将该节点的空间分配给程序。『这涉及到程序的内存管理』

申请效率的差异：

1. 栈速度较快
2. 堆速度较慢，容易产生内存碎片，如果忘记回收资源，可能会造成内存泄漏的问题

# 内存问题

1. 缓冲区溢出

```c++
strcpy()
dest[] 空间不够

``` 

2. 内存泄漏
    - 忘记回收资源
3. 对同一资源 delete 多次
4. 内存访问越界
    - 数组越界
    - string 没有结束符 '\0'
    - strcpy，strcat 等操作，缓冲区溢出
5. 非法指针
    - 野指针，引用已经释放的指针

# 内存对齐

对于标准类型，地址只要是它的长度的整数倍即可，而非标准数据类型按下面的原则：

1. 数组：第一个对齐后面自然对齐
2. union：按其包含的长度最大的数据类型对齐
3. 结构体：见下

对于 C 的结构体，遵循以下对齐规则：

1. 结构体的第一个成员的 offset 为 0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值较小的那个的整数倍。

> 有效对齐值： `pragma pack(n)` 和结构体中最长数据类型长度中较小的，也称为对齐单位，默认字节对齐为 4B，即 `pragma pack(4)`

2. 结构体总大小为有效对齐值的整数倍，如有需要编译器会加上填充字节。

```c++
// 32-bit 系统
struct abc{
    char a;
    int b;
    short c;    // 2 B
};
sizeof(struct abc) 是 1（char a） + 3（填充字节） + 4（int b） + 2（short c）  + 2（整个结构体的字节填充）= 12B
```

而 
```c++
struct abc_{

    int a;
    char b;
    short c;

}; 
sizeof(abc_) = 4（int b） + 1（char b） + 1（填充字节） + 2（short c）= 8B

``` 

# C/C++ 的区别

1. C++ 几乎是 C 的超集
2. C++ 包含面向对象，C 只包含面向过程
3. 编译方式和链接方式不同，比如 C 不支持重载，函数名解析不同。

> 设计哲学不同。C 编译速度快，容易学习。简单易学就是 C 最大的优点。

## int fun() and int fun(void) 的区别？

C 中包含默认类型机制，因此。C 编译器对待没有返回类型的函数声明和定义，默认其返回 int。而 C++ 中则会报错。另外在 C 中，int fun() 和 int fun(void) 是不同的：

1. int fun() 可以接受任一个数和类型的参数

```c
#include <stdio.h>
fun()
{
    printf("hello world");
}

int main()
{
    fun(1, 2, 3);   // ok
}
```

2. int fun(void) 只可以接受一个 void 类型

C++ 中，两者是相同的。

## C 中的 const 和 C++ 中的 const

1. C 中的 const 变量是可以修改的。因为局部 const 会被保存在栈区，而不是常量存储区【read-only】。但是全局 const 会被保存为 read-only。
    - C 中的局部 const，编译期不可修改，运行时可以。
2. C++ 中的 const 都是存放在 read-only 区。因此不可修改。
    - C++ 只有字面量初始化的 const 常量才会被加入符号表【该符号表不可修改】
    - 而变量初始化的 const 为只读变量。

## 指针和引用的区别

> 引用就是指针常量的封装，因此指针常量和引用都必须初始化，而且一旦绑定就不可更改绑定对象。

1. ++ 自增运算符，作用指针，指针本身自增其指向类型的大小。作用引用，引用绑定对象的自增操作。
2. sizeof 指针返回指针大小，即 32bit 系统为 4 字节，64bit 为 8 字节。对于引用，返回其绑定对象的大小。
3. 解引用只可以作用于指针
4. 指针可以为 NULL，引用不可以。
5. 引用应用于拷贝构造函数的形参。
6. 引用的可读性更佳

# 多态

1. 虚函数和动态绑定机制
2. 函数重载 （静态绑定)

# 隐藏

1. 派生类的函数和基类的函数重名，但是参数不同。此时，不论是否有 virtual 关键字，基类的函数都被『隐藏』，而不是重载。这和 name lookup 作用规则有关
2. 派生类的函数和基类的函数重名，参数也相同。基类函数没有 virtual 关键字，基类的函数被隐藏，不是 override

# extern c 

1. c++ 程序调用 c 的程序时，将会通知编译器，接下来的代码段按照 c 的编译和链接方式进行
    - c++ 支持重载，c 不支持，这和两者的名字解析相关

# const:

1. 修饰变量  不可修改 
* top level const   
* lower level const

```c++
const int a; 底层 const
int *b=const_cast<int *>(a); 
// b 指向 a 的地址
但是 输出 b 的值和输出 a 的值 不一致，a本身的值并没有改变。
结果是未定义的。。。

使用 const_cast 并不真正的转换被转换对象本身的 const 属性

``` 

1. 修饰成员函数，修饰的是 `this` 指针，不能改变 `this` 绑定的对象

static：

1. 修饰函数内变量，声明周期延长至程序结束，存储在静态区。使用默认初始化。
2. 修饰普通函数，限制该函数的作用域，该函数的作用域仅当前模块可见
3. 修饰全局变量，同上
4. 修饰类的数据成员，不归属于某一个类的对象，和整个类绑定在一起，所有类的对象都可以访问
    - 静态成员存储在数据段，不保存在对象内存布局中，一般不需要绑定 `this` 指针，所以普通成员函数不可以访问
5. 修饰的类的成员函数，用来访问静态数据成员，没有 `this` 指针，不绑定任何类的对象，因此该函数不可以访问非静态成员

# this 指针

1. 类的数据成员和成员函数是分开存储的，每个类的对象都会通过this指针绑定，来调用相应的成员函数，即每个成员函数中都有一个隐含的参数，即 this 指针【当然这个成员函数不可以是静态成员函数】
2. this 指针的类型是 `Foo * const this` ，this 一经初始化绑定就不可更改， 
    - const 成员函数，即为了修饰 `this` 为 `const Foo * const this`
3. this 是一个右值（形参），不可以对其取地址

# inline 

1. 请求编译器内联展开某段代码，区别于宏展开
2. 有类型检查，发生在编译阶段；宏发生在预处理阶段
3. 消除了宏的语义风险。
4. 节省函数调用开销（对于函数体有限制，复杂逻辑的函数，不适合inline），函数调用会占用栈空间，还有入栈出栈的操作
5. 类内定义的成员函数，隐式inline
6. 代码体积膨胀

## 如何处理 inline

1. inline 函数复制到调用处（编译阶段）
2. 为 inline 函数中的局部变量分配内存空间

# volatile

1. 防止编译器优化

```c++
volatile int *p = ...
int a, b; 
a = *p; 
b = *p; 
// 此时编译器可能会优化成一次访问操作，因为a从内存中读取p的值后保存在了寄存器中，此时b直接被优化成从寄存器中取值

```

2. 每次从内存中取值，编译器优化，可能每次都是从寄存器中取值（为了速度）
3. const 可以是 volatile（只读的状态寄存器）
4. 指针也可以是 volatile

> 也是一种解决线程安全的方法？每次访问该对象，都从其内存地址处取值，而不是寄存器副本中或自己的私有工作空间取值。每个线程对 volatile 变量修改后，都要写回内存。这样其他线程就可以看到该变量被修改过。这一点是因为操作系统对 volatile 变量访问时，加了锁。锁住总线。这样就可以只有一个处理器可以进行内存读写。保证同步。

# assert

C中的断言宏，条件返回错误，则终止，调用 abort 函数

# sizeof

1. 作用数组，得到整个数组的大小（虽然数组名可以隐式转换为指向数组元素的指针）
    - 当一个指针形参是一个数组形式的时候，sizeof 依然返回的是指针大小
    - `size_t fun(int arr[100]){return sizeof(arr);}` 返回 4
    - 因为 sizeof 是编译时行为，故而形参被转换为指针
2. 作用指针，指针本省占用的大小
3. 作用，引用。引用绑定对象的大小
4. 一般来说，sizeof 是编译器行为

# pragma pack(n)

结构体内存对齐指令，指定对齐大小。

# extern `C`

以 C 的方式编译和链接，C和C++编译方式有些许区别的。以防止会出现C++编译和链接方式导致的不一致问题。

# union

1. 默认权限为 public
2. 包含多个数据成员，任意时刻只有一个成员可以有值。当某个成员被赋值后，其他成员变为未定义状态
3. 可以包含构造函数、析构函数
4. sizeof 为其包含最大成员的长度

```c++
union Foo{

    Foo():a(10){}
    int a;
    double d;

}

``` 

# explicit 修饰关键字

1. 不可以隐式转换为类对象【修饰类的构造函数】

```c++
explicit vector(int n); 
void func(vector<int> vc); 
func(2); // error

""->string 类型不是 explicit 的

void func(string str){}
func("123"); // ok，“123"会隐式转换为 string 的临时对象

```

2. 对于转换函数，有时不可以防止隐式转换

# friend

1. 可以访问类的私有成员
2. 破坏封装性
3. 友元关系不可继承

最经典的用法，即重载 `<<` 和 `>>` 运算符
还可以用在 iterator 上

# using

1. 类型重定义是 typedef 可读性更佳的版本

```c++
typedef char * PCHAR; 
PCHAR a, b; // a, b 都是 char *
using PCHAR = char *; 

``` 

对于函数指针的 using 声明，可读性更佳

2. 扩大变量或函数匹配检索作用域

```c++
using std::swap; 
swap(...)
// 如果该类没有定义 swap 函数，则扩大匹配范围，到 std 命名空间搜索

```

# :: 域作用符

1. 全局作用域(::name)
2. 类作用域
3. 命名空间

# 引用

1. `const int & a` 可以绑定左值，右值，常量左值等。
2. 右值引用对象本身是一个左值

``` 

int &&a=b; // b 是一个右值
// a 本身也是一个左值

```

## 引用折叠

1. 作于模板类型推导中

``` 

&& && -> &&
&& & -> &
& && -> &
& & -> &

```

# move 语义

1. move 并不真正移动对象
    - 只有一个类定义了移动拷贝/移动赋值时 其才会移动
    - 左值引用可以绑定右值，故如果没有定义移动拷贝/赋值，则会匹配左值引用版本
2. std::move 只是将参数返回一个右值引用 就是对 `static_cast<T&>` 的封装

```c++
template<typename T>
constexpr typename std::remove_reference<T>::type&& move(T &&t) noexcept{

    using return_type = typename remove_reference<T>::type &&; 
    return static_cast<return_type>(t);

}

``` 

# forward 完美转发

1. 完美转发类型

```c++
template <typename T>
T&& forward(typename std::remove_reference<T>::type& param)
{
    return static_cast<T&&>(param);
}

template <typename T>
T&& forward(typename std::remove_reference<T>::type&& param)
{
    return static_cast<T&&>(param);
}

param 是左值时，即 T 为 int &，实例化第一个版本，则 static_cast<T&&> 会发生引用折叠，折叠为 int &，类型
param 是右值时，即 T 为 int &&，实例化第二个版本，则 static_cast<T &&> 折叠为 int &&
```

# 类的三大特性

1. 封装  
    - 类/结构体 数据部分/方法部分
2. 继承
3. 多态：动态绑定机制
    1. 重载多态：编译器
    2. 动态绑定机制：虚函数
    3. 参数多态：模板

1. 静态多态
    - 函数重载
2. 动态多条
    - 虚函数 virtual，派生类重写的虚函数默认为virtual，没有重写，则继承基类的方法

> static 函数不可以是虚函数，因为没有 this 指针

# 虚析构函数

动态绑定机制，合理的回收资源。

# 纯虚函数

抽象类。只是定义接口，不定义抽象类中的纯虚函数。

1. 不可以定义抽象类的对象

# 虚函数表

虚函数指针，指向虚函数表。运行时确定。C++中类的数据和操作是分开的，存放在不同的地方。每个函数有一个地址。不含有虚函数时，即不需要动态绑定的时候，编译期间就可以把函数地址确定下来，即静态绑定。

而动态绑定（延迟绑定），编译器通过一个虚函数表实现，每个类都有一个指针指向虚函数表的开头，该虚函数表存储的有基类的虚函数、派生类的虚函数，也包含普通的继承的成员函数。故虚函数的调用取得是哪个版本，是在运行期间通过查虚函数表来确定的。

基类的指针/引用绑定到派生类的对象时，会通过派生类的 指向虚函数表的指针，来查询对应的成员函数的地址。如果没有重写虚函数，则基类和派生类的虚函数表中的方法指向同一个地址（基类的成员函数地址）。

# 内存管理

malloc，calloc，realloc，free

1. C 中的函数
2. new,delete c++ 运算符，可以基于 malloc/free 封装，并会调用构造和析构函数
3. 空间配置类中的 deallocate，allocate。

# 智能指针

引入原因：

1. 人为原因，忘记释放资源
2. 异常导致无法释放资源

C++ 中的 RAII 特性，利用C++ 语言局部对象自动销毁的特性来控制资源的声明周期。将资源控制封装在一个类中，构造函数中申请资源，析构函数回收资源。C++确保析构函数在异常发生时，也会被执行。智能指针就是 RAII 特性的体现。通用实现即使用引用计数

1. weak_ptr 不具有资源的所有权，只有使用权，使用 弱引用计数。
    - 某种程度上来说，raw 指针也是一个 weak_ptr 
    - 可以解决循环引用的问题
2. shared_ptr 共享资源所有权，引用计数，引用计数减到0，则释放资源。
3. unique_ptr 独占资源所有权。因此，unique_ptr不支持普通的拷贝和赋值操作。类似浅拷贝问题。

# 线程安全

什么是线程安全？

简单来说，就是同一资源被多个线程访问时，保证不会出现数据污染的情况。

根据《java concurrency in practice》的定义，一个线程安全的类应当满足：

1. 多个线程同时访问，其表现正确的行为
2. 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织，其都可以表现出正确的行为
3. 调用端代码无需额外的同步机制或其他协调动作。

按照该定义，C++ 标准库的大多数 class 都不是线程安全的，如 std::string, std::vector, std::map, std::shared_ptr。而 C 库的大多数函数都是线程安全的。

另外一种定义，同一类型的多个对象能分别被各自所属的不同线程并发访问，就算是线程安全的。这种定义，STL 中大多数都是『线程安全』的【该定义一般称之为 thread compatible】。

## shared_ptr 与线程安全

> 参考 [陈硕-csdn-为什么多线程读写shard_ptr要加锁？](https://blog.csdn.net/Solstice/article/details/8547547)

shared_ptr 中的引用计数本身是安全且无锁的，但是对 shared_ptr 对象的读写需要加锁。

1. shared_ptr 对象中 `ref_count` 指向堆上的 `ref_count` 对象。该对象中的 `use_count` ，即引用计数，其自增和自减都是『原子操作』。

仅改变 shared_ptr 对象中的 `ref_count` 指向的 `ref_count` 对象的 `use_count` 是线程安全的。

```c++
auto p1 = make_shared<T> (43); 
auto p2 = p1; // 读操作

``` 

2. 而涉及到 `ptr` 写的操作，如 shared_ptr 对象中的 `ptr` 指向另一个对象。

该情况，就需要加锁来保证安全。

## 如何确保线程安全？

1. 加锁
2. 原子操作
3. 某些情况下，每个线程拷贝一份副本到自己的私有栈内存上。即共享数据的私有化

如果一个函数没有共享数据的情况，即不需要确保同步时，它显然是线程安全的。此外，由于各个线程拥有自己的私人空间（栈内存)，由此，下面的函数也是线程安全的。

```c++
double foo(vector<double> arr){

    double sum = 0;
    for(auto iter:arr)sum += iter;
    int coun = arr.size();
    double avg = sum / count;
    return avg;

}
```

该函数的局部变量都是保存在栈内存中，即每个线程都是拥有独立的副本。而全局变量或其他保存在堆上的变量是公共的，大家都可以访问。

不止如此，如果一个函数不对公有变量进行修改操作，或该变量是只读的公有变量，那么也是线程安全的。

# staic 的作用

1. 函数内的 `static` 变量，表明该变量的声明周期延续到程序终止
2. 修饰全局变量，表明该变量的作用域限制在该文件内（模块内）
3. 修饰函数，同修饰全局变量
4. 修饰类的数据成员，表明该类所有对象共享该实例，该实例和类绑定在一起，不归属为某一个对象
5. 修饰类的成员函数，该成员函数用来访问类的 `static` 成员，该成员函数不需要 `this` 指针绑定对象，因此该函数也不可以访问非静态成员函数

# 基类的析构函数不是虚函数？

在使用基类指针或引用实现多态的时候，必须确保可以调用相应的析构函数。如果不是虚函数，则可能

* `new` 出来资源无法正确回收
* 由于指针或引用类型是基类，故而通过该指针调用的析构函数，都将会调用基类版本的析构函数，故而不会调用派生类的析构函数，从而造成内存泄漏

# 编译和链接

源代码->编译->汇编代码->汇编->目标文件->链接->可执行文件

# 红黑树和哈希表

1. 数据量小的时候，哈希表较优，冲突碰撞小
2. 数据量大的时候，哈希表占用内存较大；且计算哈希值也需要一定的时间开销。数据量越大，碰撞的几率越大。内存效率比红黑树低很多。哈希表的resize非常耗时。
3. 红黑树支持有序遍历，支持 ++iterator 操作
4. 红黑树插入删除操作不会影响当前迭代器。
5. 红黑树支持范围查找
6. 红黑是支持双向遍历
7. 红黑树查找小路稳定
