# 浮点数

浮点数是相对于定点小数而言的。定点小数即小数点固定在某一位，如 $S.b_1b_2b_3\ldots b_n$，其中 S 是符号位。

定点整数就是小数点固定在最后一位，即 $Sb_1b_2\ldots b_n.$

而浮点数则是小数点位置不固定，通过『阶码』来确定。

在 [浮点数的规格化](https://www.docin.com/p-1993180748.html) 中，介绍了为何『补码的规格化』不包括 `1.1000....`

## 规格化

为了提高运算速度和充分利用尾数的有效位。即规格化后的尾数的最高数位必须是一个有效值。

所谓规格化，即通过调整一个非规格化浮点数的尾数和阶码的大小，使 **非零** 的浮点数在尾数的最高数位上保证是一个有效值。

对于二进制浮点数【一般格式，不一定是 IEEE 754 标准格式】，$2^E\times M$，规格化的数需要满足 $1/2\leq |M| \leq 1.$

对于补码来说，规格化的浮点数意味着：
* 如果是正数，尾数的第一位为 1
* 如果是负数，尾数的第一位应该为 0，或为 1 而之后各位全为 0，如 `1.10000000`，该数字为 -1/2，满足  $1/2\leq |M| \leq 1$ 的限制

1. 对于原码来说，规格化的形式如下：
    - 正数： `0.1*******`，最大值为 `0.11111111`，最小值为 `0.10000000`。
    - 负数： `1.1*******`【注意，最高有效位不是符号位】，此时的 `1.1*******` 满足 $1/2\leq |M| \leq 1$.
2. 对于补码来说，规格化的形式如下：
    - 正数： `0.1*******`，最大值为 `0.11111111`，最小值为 `0.10000000`。
    - 负数： `1.0*******`，最大值为 `1.01111111`，最小值为 `1.00000000`。

## 为什么补码的负数规格化形式不包括 `1.10000000` ？

对于负数的补码，规格化形式可以为

* `1.0*******`
* `1.10000000`，即 -1/2【该数的原码形式也是 `1.10000000`】

这两个形式都满足规格化的尾数要求，即 $1/2 \leq |M| \leq 1$。

但是为了机器判断方便，补码表示中，往往不把 -1/2 列入规格化的数字。因为此时判断一个尾数是否是规格化的数字，只需要判断『最高位』和『符号位』是否相同即可。

综上，补码的规格化数规定如下：

1. 对于 $x\geq0$，如果 $1\geq x\geq 1/2$，补码形式为 `0.1*******`
2. 对于 $x < 0 $，如果 $-1/2 > x \geq -1$，形式为 `1.0*******`

## 为什么规格化补码负数的表示中不包括类似于 `1.1*******`？

对于规格化而言，不是说除了符号位而言，尾数的最高位是 1，即有效的。这个条件是相对于原码表示而言的，对于补码表示，如 `1.11001010`，其原码表示为 `1.00110100`，也就是说，该数不满足 $1/2\leq |M| \leq 1$ 的限制。

## IEEE 754

IEEE 754 是浮点数的一个工业标准。对于单精度 `float` 类型来说，其由下面构成

``` 

| 1 bit(sign) | 8 bits(阶码) | 23 bits(尾数) |
```

其中，值得注意的是阶码用『移码』（即补码 + offset 127）来表示。尾数使用『原码』来表示。此外，尾数部分规格化后最高位一定是 1，所以 IEEE 754 标准将此 1 隐含。

故 IEEE 754 标准中，规格化的 `float` 的真值是 $(-1)^s \times (1 + M) \times 2^{E - 127}$。

> 一般来说，对于 n bits 移码来说，其 offset 为 $2^n$。不过这里的 offset 为 127，这是因为下面的原因。

* 阶码 E 为全 0 且尾数 M 也为全 0，表示的真值 X 为 **0**。结合符合位 s，有正零和负零之分。
* 阶码 E 为全 1 且尾数 M 为全 0，表示的 X 为无穷大，当然有＋∞ 和 -∞ 之分。

> 尾数 M 为全 1 时是一个正常的尾数值。

## 浮点数的舍入

在 『对阶』 和 『右规』 的过程中，可能会将尾数地位丢失，引起误差，影响精度。故常见的舍入方法有：0舍1入法和恒置1法。

注意，丢失后精度后左端直接补 0，而不是直接舍入，舍入过程是规划化尾数和之后的操作，具体见下

对于浮点数的 “**0舍1入**” 法：0 舍 1 入，类似于十进制的“四舍五入”，指的是『**舍去的位中的最高位是 0 还是 1**』。

如 $X = 2^{010} \times 0.11011011, Y = 2^{100} \times (-0.10101100)$。

两个数的补码分别为 $[X]_{补}=00,010;00,11011011$，$[Y]_{补}=00,100;11,01010100$

1. 对阶
阶差 $\Delta E = [E_x]_{补}+[E_y]_{补}=00,010+11,100=11,110=-2$，故 X 阶码小，MX 右移两位，阶码 EX 加 2。

注：这里是 **对阶** 产生的丢失，左端直接补 0。

1. 尾数求和
$$
[MX]_{补} + [MY]_{补} = 00,00110110+ 11,01010100 = 11,10001010(11)=M
$$

3. 规格化
左规，移一位，结果为 $M=11,00010101(10)$；阶码减 1，得 $E = 00,011$。

左规得过程中可能会把 (11) 中的数值先移动到实际数据中，直到得到规格化的数

4. 舍入
移出的(10)最高位为1，故结果位最低位加 1，得 $[MX]_{补}+[MY]_{补}=11,00010110$。

5. 判断是否溢出
阶码 $E=00,011$，符号位为 00，无溢出。

>　尾数溢出并不代表浮点数溢出，尾数溢出左规右规即可，由阶码来判断浮点数运算结果是否溢出。

其中，(11) 代表
M = 11，00010101（10）；此时舍去位是括号中的 10（即十进制的 2），故进 1，因此 M = 11，00010110。
