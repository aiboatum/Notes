# 浮点数

浮点数是相对于定点小数而言的。定点小数即小数点固定在某一位，如 $S.b_1b_2b_3\ldots b_n$，其中 S 是符号位。

定点整数就是小数点固定在最后一位，即 $Sb_1b_2\ldots b_n.$

而浮点数则是小数点位置不固定，通过『阶码』来确定。

在 [浮点数的规格化](https://www.docin.com/p-1993180748.html) 中，介绍了为何『补码的规格化』不包括 `1.1000....`

## 规格化

为了提高运算速度和充分利用尾数的有效位。即规格化后的尾数的最高数位必须是一个有效值。

所谓规格化，即通过调整一个非规格化浮点数的尾数和阶码的大小，使 **非零** 的浮点数在尾数的最高数位上保证是一个有效值。

对于二进制浮点数【一般格式，不一定是 IEEE 754 标准格式】，$2^E\times M$，规格化的数需要满足 $1/2\leq |M| \leq 1.$

对于补码来说，规格化的浮点数意味着：
* 如果是正数，尾数的第一位为 1
* 如果是负数，尾数的第一位应该为 0，或为 1 而之后各位全为 0，如 `1.10000000`，该数字为 -1/2，满足  $1/2\leq |M| \leq 1$ 的限制

1. 对于原码来说，规格化的形式如下：
    - 正数： `0.1*******`，最大值为 `0.11111111`，最小值为 `0.10000000`。
    - 负数： `1.1*******`【注意，最高有效位不是符号位】，此时的 `1.1*******` 满足 $1/2\leq |M| \leq 1$.
2. 对于补码来说，规格化的形式如下：
    - 正数： `0.1*******`，最大值为 `0.11111111`，最小值为 `0.10000000`。
    - 负数： `1.0*******`，最大值为 `1.01111111`，最小值为 `1.00000000`。

## 为什么补码的负数规格化形式不包括 `1.10000000` ？

对于负数的补码，规格化形式可以为

* `1.0*******`
* `1.10000000`，即 -1/2【该数的原码形式也是 `1.10000000`】

这两个形式都满足规格化的尾数要求，即 $1/2 \leq |M| \leq 1$。

但是为了机器判断方便，补码表示中，往往不把 -1/2 列入规格化的数字。因为此时判断一个尾数是否是规格化的数字，只需要判断『最高位』和『符号位』是否相同即可。

综上，补码的规格化数规定如下：

1. 对于 $x\geq0$，如果 $1\geq x\geq 1/2$，补码形式为 `0.1*******`
2. 对于 $x < 0 $，如果 $-1/2 > x \geq -1$，形式为 `1.0*******`

## 为什么规格化补码负数的表示中不包括类似于 `1.1*******`？

对于规格化而言，不是说除了符号位而言，尾数的最高位是 1，即有效的。这个条件是相对于原码表示而言的，对于补码表示，如 `1.11001010`，其原码表示为 `1.00110100`，也就是说，该数不满足 $1/2\leq |M| 1$ 的限制。

## IEEE 754

IEEE 754 是浮点数的一个工业标准。对于单精度 `float` 类型来说，其由下面构成

``` 

| 1 bit(sign) | 8 bits(阶码) | 23 bits(尾数) |
```

其中，值得注意的是阶码用『移码』（即补码 + offset 127）来表示。尾数使用『原码』来表示。此外，尾数部分规格化后最高位一定是 1，所以 IEEE 754 标准将此 1 隐含。

故 IEEE 754 标准中，规格化的 `float` 的真值是 $(-1)^s \times (1 + M) \times 2^{E - 127}$。

> 一般来说，对于 n bits 移码来说，其 offset 为 $2^n$。不过这里的 offset 为 127，这是因为下面的原因。

* 阶码 E 为全 0 且尾数 M 也为全 0，表示的真值 X 为 **0**。结合符合位 s，有正零和负零之分。
* 阶码 E 为全 1 且尾数 M 为全 0，表示的 X 为无穷大，当然有＋∞ 和 -∞ 之分。

> 尾数 M 为全 1 时是一个正常的尾数值。

## 浮点数的舍入

对于浮点数的 “0 舍 1 入”法，例子见 [CSDN: 浮点加减运算之0舍1入法与恒置1法](https://blog.csdn.net/qq_45737068/article/details/108714254)。

0舍1入，类似于十进制的“四舍五入”，指的是『舍去的位中的最高位是0还是1』。如规格化后的数字是 M = 11，00010101（10）；此时舍去位是括号中的 10，故进 1，因此 M = 11，00010110.
